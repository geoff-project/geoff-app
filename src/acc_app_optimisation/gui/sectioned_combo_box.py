# SPDX-FileCopyrightText: 2024 CERN
# SPDX-FileCopyrightText: 2024 GSI Helmholtzzentrum f√ºr Schwerionenforschung
# SPDX-FileNotice: All rights not expressly granted are reserved.
#
# SPDX-License-Identifier: GPL-3.0-or-later OR EUPL-1.2+

"""Provide :class:`SectionedComboBox`."""

import sys
import typing as t

from PyQt5 import QtCore, QtGui, QtWidgets

if sys.version_info < (3, 11):
    from typing_extensions import Self
else:
    from typing import Self


class TitleItem(QtGui.QStandardItem):
    """Item class for title items.

    Title items are identified by the data of role `TitleItemRole`. If
    it exists and is True, the item is a title item.
    """

    TitleItemRole: t.Final = QtCore.Qt.UserRole + 231  # pylint: disable = invalid-name

    @t.overload
    def __init__(self) -> None: ...
    @t.overload
    def __init__(self, text: str) -> None: ...
    @t.overload
    def __init__(self, icon: QtGui.QIcon, text: str) -> None: ...
    @t.overload
    def __init__(self, rows: int, columns: int = ...) -> None: ...
    @t.overload
    def __init__(self, other: Self) -> None: ...
    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:
        super().__init__(*args, **kwargs)
        self.setData(True, self.TitleItemRole)
        self.setEnabled(False)
        self.setSelectable(False)
        self.setForeground(QtCore.Qt.gray)
        font = self.font()
        letter_spacing = QtGui.QFontInfo(font).pixelSize() / 4
        font.setLetterSpacing(QtGui.QFont.AbsoluteSpacing, letter_spacing)
        font.setCapitalization(QtGui.QFont.SmallCaps)
        self.setFont(font)


class SectionedComboBox(QtWidgets.QComboBox):
    """A combo box in which items are separated into sections.

    Each section has a title. Title items are generated by the method
    `create_title_item()`, which can be overridden in subclasses. By
    default, it returns a `TitleItem`.

    Whether an item is a title item is determined by a custom role,
    `TitleItem.TitleItemRole`; you can check whether a row contains
    a title item with `isTitleRow()`.

    Add items with `appendSection()` and `insertSection()`; remove them
    with `removeSection()`.

    Args:
        parent: The parent widget, if any.
    """

    # pylint: disable = invalid-name

    def create_title_item(self, title: str) -> QtGui.QStandardItem:
        return TitleItem(title)

    def appendSection(self, title: str, items: t.Iterable[str]) -> None:
        """Add a section to the end of the combo box.

        This is equivalent to
        :samp:`{self}.insertSection({self}.sectionCount(), {title},
        {items})`.

        Args:
            title: The text of the title item.
            items: The items of this section.
        """
        # Add the items before their title. Otherwise, if the combo box
        # is initially empty, the title ends up pre-selected, even if
        # the item is disabled or unselectable.
        row = self.count()
        title_item = self.create_title_item(title)
        model = self.model()
        assert isinstance(model, QtGui.QStandardItemModel), model
        self.addItems(items)
        model.insertRow(row)
        model.setItem(row, 0, title_item)

    def insertSection(
        self, before_section: int, title: str, items: t.Iterable[str]
    ) -> None:
        """Add a section to this combo box.

        Args:
            before_section: Index of the section before which to insert
                the new one. Use ``0`` to insert before the first
                section; use `sectionCount()` to insert after the last
                section.
            title: The text of the title item.
            items: The items of this section.
        """
        row = self.getTitleRow(before_section)
        if row < 0:
            raise ValueError(f"'before_section' must be 0 or greater: {before_section}")
        title_item = self.create_title_item(title)
        model = self.model()
        assert isinstance(model, QtGui.QStandardItemModel), model
        self.insertItems(row, items)
        model.insertRow(row)
        model.setItem(row, 0, title_item)

    def removeSection(self, section: int) -> None:
        """Delete a section from this combo box.

        Args:
            section: The index of the section to delete. ``0`` is the
                first section; ``sectionCount()`` is the last section;
                ``-1`` deletes all items that were inserted before the
                first section.
        """
        row_start = self.getTitleRow(section)
        row_end = row_start + 1
        while row_end < self.count() and not self.isTitleRow(row_end):
            row_end += 1
        # If row_start was negative, set it to zero _now_. This ensures
        # that an untitled section before all titled sections is handled
        # correctly. (You need to count one row less for it, since it
        # doesn't have a title item.)
        row_start = max(0, row_start)
        count = row_end - row_start
        model = self.model()
        assert isinstance(model, QtGui.QStandardItemModel), model
        model.removeRows(row_start, count)

    def findTitleRowByRow(self, row: int) -> int:
        """Search backwards from the given row to the first title row.

        If the given row is a title row, it is returned immediately. If
        there is no title row for this item, ``-1`` is returned.
        """
        while row >= 0 and not self.isTitleRow(row):
            row -= 1
        return row

    def getTitleRow(self, section: int) -> int:
        """Return the index of the title row for the given *section*.

        If there are no title rows, `count()` is returned. If *section*
        is negative, ``-1`` is returned.
        """
        if section < 0:
            return -1
        count = self.count()
        for row in range(count):
            if self.isTitleRow(row):
                if section:
                    section -= 1
                else:
                    return row
        return count

    def isTitleRow(self, row: int) -> bool:
        """Return True if the given *row* is a title row, otherwise False."""
        return bool(self.itemData(row, TitleItem.TitleItemRole))

    def sectionCount(self) -> int:
        """Return the number of title rows in the combo box.

        Note that if rows are manually inserted before the first title
        row, they do not count as a separate section.
        """
        return sum(map(self.isTitleRow, range(self.count())))
